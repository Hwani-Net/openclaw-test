<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Nyong Mario</title>
  <style>
    :root {
      --sky1: #7dd3fc;
      --sky2: #dbeafe;
      --ground: #16a34a;
      --ui: #0f172a;
      --panel: rgba(15,23,42,.75);
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(180deg, var(--sky1), var(--sky2));
    }
    #wrap {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at 50% 0%, #bae6fd 0%, #7dd3fc 35%, #38bdf8 100%);
    }
    canvas {
      width: min(100vw, 1200px);
      height: min(100vh, 675px);
      max-width: 100%;
      max-height: 100%;
      border-radius: 14px;
      box-shadow: 0 24px 50px rgba(2,6,23,.35);
      background: linear-gradient(180deg, #7dd3fc 0%, #bfdbfe 65%, #86efac 100%);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      background: var(--panel);
      color: #fff;
      border-radius: 12px;
      padding: 8px 12px;
      font-weight: 700;
      z-index: 20;
      display: flex;
      gap: 12px;
      font-size: 14px;
      backdrop-filter: blur(6px);
    }
    .touch {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 12px;
      display: none;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 14px;
      z-index: 25;
      pointer-events: none;
    }
    .touch .grp {
      display: flex;
      gap: 10px;
      pointer-events: auto;
    }
    .btn {
      width: 62px;
      height: 62px;
      border: none;
      border-radius: 999px;
      background: rgba(15,23,42,.75);
      color: #fff;
      font-size: 24px;
      font-weight: 900;
      box-shadow: 0 10px 20px rgba(2,6,23,.35);
    }
    .btn.jump { background: rgba(236,72,153,.85); }
    .btn:active { transform: scale(.95); }
    @media (max-width: 900px) {
      .touch { display: flex; }
      .hud { font-size: 12px; padding: 7px 10px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="540"></canvas>
  </div>
  <div class="hud">
    <span id="hudCoins">코인 0</span>
    <span id="hudLives">목숨 3</span>
    <span id="hudTime">시간 120</span>
    <span id="hudState">진행중</span>
  </div>

  <div class="touch">
    <div class="grp">
      <button class="btn" id="leftBtn">◀</button>
      <button class="btn" id="rightBtn">▶</button>
    </div>
    <div class="grp">
      <button class="btn jump" id="jumpBtn">▲</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const hudCoins = document.getElementById('hudCoins');
  const hudLives = document.getElementById('hudLives');
  const hudTime = document.getElementById('hudTime');
  const hudState = document.getElementById('hudState');

  const W = canvas.width;
  const H = canvas.height;
  const GROUND_Y = 470;

  const keys = new Set();
  const touchState = { left: false, right: false, jump: false };

  const world = {
    width: 5200,
    ground: [],
    platforms: [],
    coins: [],
    enemies: [],
    pits: [],
    flagX: 5000
  };

  const state = {
    player: null,
    cameraX: 0,
    lives: 3,
    coins: 0,
    time: 120,
    running: true,
    result: '',
    lastTs: 0,
    elapsed: 0
  };

  function rect(x, y, w, h) { return { x, y, w, h }; }

  function resetPlayer(x = 80, y = 360) {
    state.player = {
      x, y,
      w: 34,
      h: 42,
      vx: 0,
      vy: 0,
      onGround: false,
      dir: 1,
      invulMs: 0
    };
  }

  function buildWorld() {
    world.ground = [];
    world.platforms = [];
    world.coins = [];
    world.enemies = [];
    world.pits = [];

    // Main ground segments
    world.ground.push(rect(0, GROUND_Y, 800, 80));
    world.ground.push(rect(900, GROUND_Y, 700, 80));
    world.ground.push(rect(1750, GROUND_Y, 620, 80));
    world.ground.push(rect(2500, GROUND_Y, 850, 80));
    world.ground.push(rect(3450, GROUND_Y, 850, 80));
    world.ground.push(rect(4380, GROUND_Y, 820, 80));

    // Platforms
    const pf = [
      [460, 390, 120], [620, 330, 100], [1080, 370, 120], [1360, 310, 90],
      [1920, 360, 120], [2100, 300, 100], [2720, 390, 120], [2920, 330, 120],
      [3140, 280, 100], [3660, 370, 120], [3920, 320, 90], [4540, 360, 120],
      [4760, 300, 100]
    ];
    pf.forEach(([x, y, w]) => world.platforms.push(rect(x, y, w, 20)));

    // Coins
    for (let i = 0; i < world.platforms.length; i++) {
      const p = world.platforms[i];
      const n = p.w > 110 ? 3 : 2;
      for (let j = 0; j < n; j++) {
        world.coins.push({
          x: p.x + 20 + j * ((p.w - 40) / Math.max(1, n - 1)),
          y: p.y - 22,
          r: 8,
          taken: false,
          bob: Math.random() * Math.PI * 2
        });
      }
    }
    // Ground coins on safer sections
    [220, 300, 980, 1240, 1860, 1980, 2620, 2860, 3520, 3700, 4420, 4660].forEach((x) => {
      world.coins.push({ x, y: GROUND_Y - 16, r: 8, taken: false, bob: Math.random() * Math.PI * 2 });
    });

    // Enemies (simple walkers)
    const enemySpawns = [520, 1180, 2010, 2790, 3740, 4600];
    enemySpawns.forEach((x) => {
      world.enemies.push({ x, y: GROUND_Y - 28, w: 30, h: 28, vx: 55, dir: Math.random() > .5 ? 1 : -1, alive: true });
    });

    // Pits between ground segments
    world.pits.push(rect(800, GROUND_Y, 100, 120));
    world.pits.push(rect(1600, GROUND_Y, 150, 120));
    world.pits.push(rect(2370, GROUND_Y, 130, 120));
    world.pits.push(rect(3350, GROUND_Y, 100, 120));
    world.pits.push(rect(4300, GROUND_Y, 80, 120));

    world.flagX = 5000;
  }

  function overlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function circleRect(c, r) {
    const cx = Math.max(r.x, Math.min(c.x, r.x + r.w));
    const cy = Math.max(r.y, Math.min(c.y, r.y + r.h));
    const dx = c.x - cx;
    const dy = c.y - cy;
    return dx * dx + dy * dy <= c.r * c.r;
  }

  function getSolids() {
    return [...world.ground, ...world.platforms];
  }

  function handlePlayer(dt) {
    const p = state.player;
    if (!p) return;

    const moveLeft = keys.has('ArrowLeft') || keys.has('KeyA') || touchState.left;
    const moveRight = keys.has('ArrowRight') || keys.has('KeyD') || touchState.right;
    const wantJump = keys.has('Space') || keys.has('ArrowUp') || keys.has('KeyW') || touchState.jump;

    const ACC = 1300;
    const MAX = 250;
    const FRICTION = 1400;
    const GRAV = 1600;
    const JUMP = 620;

    if (moveLeft && !moveRight) {
      p.vx -= ACC * dt;
      p.dir = -1;
    } else if (moveRight && !moveLeft) {
      p.vx += ACC * dt;
      p.dir = 1;
    } else {
      if (p.vx > 0) p.vx = Math.max(0, p.vx - FRICTION * dt);
      else if (p.vx < 0) p.vx = Math.min(0, p.vx + FRICTION * dt);
    }

    p.vx = Math.max(-MAX, Math.min(MAX, p.vx));

    if (wantJump && p.onGround) {
      p.vy = -JUMP;
      p.onGround = false;
    }

    p.vy += GRAV * dt;

    // X move + resolve
    p.x += p.vx * dt;
    for (const s of getSolids()) {
      if (!overlap(p, s)) continue;
      if (p.vx > 0) p.x = s.x - p.w;
      else if (p.vx < 0) p.x = s.x + s.w;
      p.vx = 0;
    }

    // Y move + resolve
    p.y += p.vy * dt;
    p.onGround = false;
    for (const s of getSolids()) {
      if (!overlap(p, s)) continue;
      if (p.vy > 0) {
        p.y = s.y - p.h;
        p.vy = 0;
        p.onGround = true;
      } else if (p.vy < 0) {
        p.y = s.y + s.h;
        p.vy = 0;
      }
    }

    // Bounds
    if (p.x < 0) p.x = 0;
    if (p.x + p.w > world.width) p.x = world.width - p.w;

    // Pit / fall
    if (p.y > H + 120) {
      loseLife();
      return;
    }

    // Coins
    for (const c of world.coins) {
      if (c.taken) continue;
      if (circleRect(c, p)) {
        c.taken = true;
        state.coins += 1;
      }
    }

    // Enemies
    for (const e of world.enemies) {
      if (!e.alive) continue;
      if (!overlap(p, e)) continue;

      const playerBottom = p.y + p.h;
      const enemyTop = e.y;
      const wasFalling = p.vy > 60;

      if (wasFalling && playerBottom - enemyTop < 20) {
        e.alive = false;
        p.vy = -380;
      } else if (p.invulMs <= 0) {
        loseLife();
        return;
      }
    }

    if (p.invulMs > 0) p.invulMs -= dt * 1000;

    // Win
    if (p.x >= world.flagX - 20) {
      state.running = false;
      state.result = 'WIN';
    }
  }

  function handleEnemies(dt) {
    for (const e of world.enemies) {
      if (!e.alive) continue;

      e.x += e.vx * e.dir * dt;

      const aheadX = e.dir > 0 ? e.x + e.w + 2 : e.x - 2;
      const footY = e.y + e.h + 2;

      let groundAhead = false;
      for (const g of [...world.ground, ...world.platforms]) {
        if (aheadX >= g.x && aheadX <= g.x + g.w && footY >= g.y && footY <= g.y + g.h + 4) {
          groundAhead = true;
          break;
        }
      }

      // Wall hit
      let wall = false;
      for (const s of getSolids()) {
        if (!overlap(e, s)) continue;
        wall = true;
        break;
      }

      if (!groundAhead || wall) e.dir *= -1;
    }
  }

  function updateCamera() {
    const p = state.player;
    const target = p.x - W * 0.35;
    state.cameraX += (target - state.cameraX) * 0.12;
    state.cameraX = Math.max(0, Math.min(world.width - W, state.cameraX));
  }

  function loseLife() {
    state.lives -= 1;
    if (state.lives <= 0) {
      state.running = false;
      state.result = 'LOSE';
      return;
    }
    resetPlayer(Math.max(40, state.player.x - 120), 320);
    state.player.invulMs = 1400;
  }

  function drawSky() {
    // clouds
    ctx.fillStyle = 'rgba(255,255,255,.8)';
    const cloudXs = [140, 420, 780, 1100, 1500, 1960, 2480, 2940, 3520, 4080, 4620];
    cloudXs.forEach((cx, i) => {
      const x = cx - state.cameraX * 0.35;
      const y = 80 + (i % 3) * 46;
      if (x < -200 || x > W + 200) return;
      ctx.beginPath();
      ctx.arc(x, y, 28, 0, Math.PI * 2);
      ctx.arc(x + 30, y - 10, 24, 0, Math.PI * 2);
      ctx.arc(x + 58, y, 22, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function drawGround() {
    // solids
    for (const g of world.ground) {
      const x = g.x - state.cameraX;
      if (x + g.w < -20 || x > W + 20) continue;
      ctx.fillStyle = '#16a34a';
      ctx.fillRect(x, g.y, g.w, g.h);
      ctx.fillStyle = '#15803d';
      for (let i = 0; i < g.w; i += 26) {
        ctx.fillRect(x + i, g.y + 8, 18, 8);
      }
    }

    for (const p of world.platforms) {
      const x = p.x - state.cameraX;
      if (x + p.w < -20 || x > W + 20) continue;
      ctx.fillStyle = '#b45309';
      ctx.fillRect(x, p.y, p.w, p.h);
      ctx.fillStyle = '#92400e';
      ctx.fillRect(x, p.y + p.h - 6, p.w, 6);
    }

    // pits shadow
    for (const pit of world.pits) {
      const x = pit.x - state.cameraX;
      if (x + pit.w < -20 || x > W + 20) continue;
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(x, pit.y, pit.w, pit.h);
    }
  }

  function drawCoins(t) {
    for (const c of world.coins) {
      if (c.taken) continue;
      const x = c.x - state.cameraX;
      if (x < -20 || x > W + 20) continue;
      const bob = Math.sin(t * 0.006 + c.bob) * 3;
      ctx.fillStyle = '#facc15';
      ctx.beginPath();
      ctx.arc(x, c.y + bob, c.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#eab308';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  function drawEnemies() {
    for (const e of world.enemies) {
      if (!e.alive) continue;
      const x = e.x - state.cameraX;
      if (x + e.w < -20 || x > W + 20) continue;
      ctx.fillStyle = '#7c2d12';
      ctx.fillRect(x, e.y, e.w, e.h);
      ctx.fillStyle = '#fff';
      ctx.fillRect(x + 6, e.y + 8, 6, 6);
      ctx.fillRect(x + 18, e.y + 8, 6, 6);
    }
  }

  function drawFlag() {
    const x = world.flagX - state.cameraX;
    ctx.fillStyle = '#334155';
    ctx.fillRect(x, 280, 6, 190);
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(x + 6, 292, 44, 26);
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 16px sans-serif';
    ctx.fillText('GO!', x + 12, 310);
  }

  function drawPlayer() {
    const p = state.player;
    const x = p.x - state.cameraX;
    const blink = p.invulMs > 0 && Math.floor(p.invulMs / 80) % 2 === 0;
    if (blink) return;

    // body
    ctx.fillStyle = '#2563eb';
    ctx.fillRect(x, p.y + 12, p.w, p.h - 12);
    // shirt
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(x + 5, p.y + 4, p.w - 10, 14);
    // head
    ctx.fillStyle = '#fde68a';
    ctx.fillRect(x + 8, p.y, p.w - 16, 12);
    // hat
    ctx.fillStyle = '#b91c1c';
    ctx.fillRect(x + 4, p.y - 6, p.w - 8, 8);
  }

  function drawOverlay() {
    if (state.running) return;
    ctx.fillStyle = 'rgba(15,23,42,.55)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 54px sans-serif';
    ctx.fillText(state.result === 'WIN' ? 'CLEAR!' : 'GAME OVER', W / 2, H / 2 - 20);
    ctx.font = 'bold 24px sans-serif';
    ctx.fillText('스페이스 또는 점프로 다시 시작', W / 2, H / 2 + 28);
    ctx.textAlign = 'start';
  }

  function render(t) {
    ctx.clearRect(0, 0, W, H);
    drawSky();
    drawGround();
    drawFlag();
    drawCoins(t);
    drawEnemies();
    drawPlayer();
    drawOverlay();

    hudCoins.textContent = `코인 ${state.coins}`;
    hudLives.textContent = `목숨 ${state.lives}`;
    hudTime.textContent = `시간 ${Math.max(0, Math.ceil(state.time))}`;
    hudState.textContent = state.running ? '진행중' : (state.result === 'WIN' ? '성공' : '실패');
  }

  function update(dt, t) {
    if (!state.running) return;

    state.time -= dt;
    if (state.time <= 0) {
      state.time = 0;
      state.running = false;
      state.result = 'LOSE';
      return;
    }

    handlePlayer(dt);
    handleEnemies(dt);
    updateCamera();
  }

  function resetGame() {
    state.running = true;
    state.result = '';
    state.time = 120;
    state.coins = 0;
    state.lives = 3;
    state.cameraX = 0;
    buildWorld();
    resetPlayer(80, 360);
  }

  function gameLoop(ts) {
    if (!state.lastTs) state.lastTs = ts;
    const dt = Math.min(0.033, (ts - state.lastTs) / 1000);
    state.lastTs = ts;

    update(dt, ts);
    render(ts);

    requestAnimationFrame(gameLoop);
  }

  // Inputs
  addEventListener('keydown', (e) => {
    const c = e.code;
    if (['ArrowLeft','ArrowRight','ArrowUp','Space','KeyA','KeyD','KeyW'].includes(c)) e.preventDefault();

    if (!state.running && (c === 'Space' || c === 'ArrowUp' || c === 'KeyW')) {
      resetGame();
      return;
    }
    keys.add(c);
  }, { passive: false });

  addEventListener('keyup', (e) => keys.delete(e.code));

  function bindHold(btn, key) {
    const set = (v) => { touchState[key] = v; };
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); set(true); if (!state.running && key === 'jump') resetGame(); }, { passive: false });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); set(false); }, { passive: false });
    btn.addEventListener('mousedown', () => { set(true); if (!state.running && key === 'jump') resetGame(); });
    btn.addEventListener('mouseup', () => set(false));
    btn.addEventListener('mouseleave', () => set(false));
  }

  bindHold(document.getElementById('leftBtn'), 'left');
  bindHold(document.getElementById('rightBtn'), 'right');
  bindHold(document.getElementById('jumpBtn'), 'jump');

  addEventListener('blur', () => {
    keys.clear();
    touchState.left = false;
    touchState.right = false;
    touchState.jump = false;
  });

  resetGame();
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
