<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Princess Quest - Platformer</title>
  <style>
    :root {
      --ui-bg: rgba(2, 6, 23, .72);
      --ui-line: rgba(148, 163, 184, .35);
      --txt: #f8fafc;
      --accent: #f472b6;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #020617;
    }
    #wrap {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background:
        radial-gradient(1200px 680px at 50% -10%, #38bdf855, transparent 50%),
        radial-gradient(900px 500px at -10% 100%, #fb718533, transparent 45%),
        #020617;
    }
    canvas {
      width: min(100vw, 1280px);
      height: min(100vh, 720px);
      border-radius: 14px;
      box-shadow: 0 30px 60px rgba(2, 6, 23, .55);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background: linear-gradient(180deg, #7dd3fc 0%, #bae6fd 55%, #86efac 100%);
    }
    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid var(--ui-line);
      background: var(--ui-bg);
      color: var(--txt);
      font-weight: 800;
      font-size: 13px;
      backdrop-filter: blur(8px);
      z-index: 30;
      max-width: min(95vw, 860px);
      box-shadow: 0 12px 28px rgba(2,6,23,.35);
    }
    .hud-item {
      border: 1px solid rgba(148,163,184,.3);
      background: rgba(15,23,42,.5);
      border-radius: 10px;
      padding: 4px 8px;
      display: flex;
      align-items: center;
      gap: 5px;
      min-height: 30px;
    }
    .hud-item b { color: #fff; }
    .hud-item.progress {
      min-width: 150px;
      display: grid;
      gap: 3px;
      align-items: center;
    }
    .hud-item.progress .row {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: #cbd5e1;
    }
    .hud-item.progress .bar {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(148,163,184,.25);
      overflow: hidden;
    }
    .hud-item.progress .bar i {
      display: block;
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg,#22d3ee,#f472b6);
      transition: width .2s ease;
    }
    .sound-btn {
      border: 1px solid #f472b6;
      background: linear-gradient(180deg, #f9a8d4, #ec4899);
      color: #fff;
      border-radius: 10px;
      padding: 6px 9px;
      font-weight: 900;
      font-size: 12px;
      cursor: pointer;
    }
    .touch {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 12px;
      display: none;
      justify-content: space-between;
      align-items: end;
      padding: 0 14px;
      pointer-events: none;
      z-index: 35;
    }
    .touch .grp {
      display: flex;
      gap: 10px;
      pointer-events: auto;
    }
    .tbtn {
      width: 64px;
      height: 64px;
      border: none;
      border-radius: 999px;
      font-size: 25px;
      font-weight: 900;
      color: #fff;
      background: rgba(15, 23, 42, .78);
      box-shadow: 0 10px 22px rgba(2, 6, 23, .45);
      touch-action: none;
    }
    .tbtn.jump { background: rgba(236, 72, 153, .88); }
    .tbtn:active { transform: scale(.95); }

    .menu {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2,6,23,.55);
      z-index: 40;
      padding: 16px;
      backdrop-filter: blur(4px);
    }
    .menu.show { display: flex; }
    .menu-card {
      width: min(440px, 94vw);
      border: 1px solid rgba(148,163,184,.38);
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(15,23,42,.92), rgba(30,41,59,.9));
      color: #fff;
      padding: 20px;
      box-shadow: 0 20px 50px rgba(2,6,23,.5);
    }
    .menu-title {
      font-size: 34px;
      font-weight: 900;
      letter-spacing: .02em;
      color: #fdf4ff;
      text-shadow: 0 0 24px rgba(244,114,182,.35);
      margin: 0;
    }
    .menu-sub {
      margin-top: 8px;
      color: #cbd5e1;
      font-size: 14px;
      line-height: 1.45;
    }
    .menu-cta {
      margin-top: 16px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .menu-btn {
      border: 1px solid #f472b6;
      background: linear-gradient(180deg,#f9a8d4,#ec4899);
      color: #fff;
      border-radius: 12px;
      padding: 11px 14px;
      font-weight: 900;
      cursor: pointer;
      font-size: 14px;
    }
    .menu-btn.secondary {
      border-color: rgba(148,163,184,.45);
      background: rgba(15,23,42,.55);
      color: #e2e8f0;
    }

    @media (max-width: 980px) {
      .touch { display: flex; }
      .hud { font-size: 12px; padding: 7px 8px; gap: 6px; }
      .hud-item { padding: 3px 7px; }
      .hud-item.progress { min-width: 120px; }
      .sound-btn { padding: 5px 8px; }
      .menu-title { font-size: 28px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="1280" height="720"></canvas>
  </div>

  <div class="hud">
    <div class="hud-item">ğŸª™ <b id="uiCoins">0</b></div>
    <div class="hud-item">â­ <b id="uiScore">0</b></div>
    <div class="hud-item">â¤ï¸ <b id="uiLives">3</b></div>
    <div class="hud-item">â± <b id="uiTime">150</b></div>
    <div class="hud-item">ìƒíƒœ <b id="uiState">ëŒ€ê¸°</b></div>
    <div class="hud-item progress">
      <div class="row"><span>ì§„í–‰ë¥ </span><span id="uiProgressText">0%</span></div>
      <div class="bar"><i id="uiProgressBar"></i></div>
    </div>
    <button class="sound-btn" id="soundBtn">ğŸ”Š</button>
  </div>

  <div class="touch">
    <div class="grp">
      <button class="tbtn" id="leftBtn">â—€</button>
      <button class="tbtn" id="rightBtn">â–¶</button>
    </div>
    <div class="grp">
      <button class="tbtn jump" id="jumpBtn">â–²</button>
    </div>
  </div>

  <div class="menu show" id="menu">
    <div class="menu-card">
      <h1 class="menu-title">ğŸ‘‘ Princess Quest</h1>
      <div class="menu-sub" id="menuSub">ì„±ìœ¼ë¡œ í–¥í•˜ëŠ” ê¸¸ì„ ëŒíŒŒí•˜ì„¸ìš”. ì½”ì¸ê³¼ ì ¬ì„ ëª¨ì•„ ìµœê³  ì ìˆ˜ë¥¼ ë‹¬ì„±í•˜ì„¸ìš”.</div>
      <div class="menu-cta">
        <button class="menu-btn" id="startGameBtn">ê²Œì„ ì‹œì‘</button>
        <button class="menu-btn secondary" id="restartGameBtn">ë‹¤ì‹œ ì‹œì‘</button>
      </div>
      <div class="menu-sub" style="margin-top:12px">ì¡°ì‘: â†/â†’ ì´ë™ Â· â†‘/Space ì í”„ Â· ì  ë¨¸ë¦¬ë¥¼ ë°Ÿì•„ ì²˜ì¹˜</div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  const uiCoins = document.getElementById('uiCoins');
  const uiScore = document.getElementById('uiScore');
  const uiLives = document.getElementById('uiLives');
  const uiTime = document.getElementById('uiTime');
  const uiState = document.getElementById('uiState');
  const uiProgressText = document.getElementById('uiProgressText');
  const uiProgressBar = document.getElementById('uiProgressBar');
  const soundBtn = document.getElementById('soundBtn');
  const menu = document.getElementById('menu');
  const menuSub = document.getElementById('menuSub');
  const startGameBtn = document.getElementById('startGameBtn');
  const restartGameBtn = document.getElementById('restartGameBtn');

  const keys = new Set();
  const touch = { left: false, right: false, jump: false };

  const FLOOR = 620;
  const TILE = 40;

  const world = {
    width: 9600,
    solids: [],
    platforms: [],
    pits: [],
    coins: [],
    gems: [],
    enemies: [],
    checkpoints: [],
    flagX: 9300
  };

  const state = {
    p: null,
    camX: 0,
    lives: 3,
    score: 0,
    coins: 0,
    time: 150,
    running: false,
    result: 'READY',
    lastTs: 0,
    particles: [],
    audio: { ctx: null, on: true, bgm: null },
    firstInteraction: false
  };

  function rect(x, y, w, h, type = 'solid') { return { x, y, w, h, type }; }

  function addGround(x, w) {
    world.solids.push(rect(x, FLOOR, w, H - FLOOR, 'ground'));
  }

  function addPlatform(x, y, w) {
    world.platforms.push(rect(x, y, w, 20, 'platform'));
    world.solids.push(rect(x, y, w, 20, 'platform'));
  }

  function addQuestionBlock(x, y) {
    world.solids.push(rect(x, y, 40, 40, 'qblock'));
  }

  function addCoin(x, y) {
    world.coins.push({ x, y, r: 10, taken: false, phase: Math.random() * Math.PI * 2 });
  }

  function addGem(x, y) {
    world.gems.push({ x, y, r: 12, taken: false, phase: Math.random() * Math.PI * 2 });
  }

  function addEnemy(x, y, minX, maxX, speed = 72) {
    world.enemies.push({ x, y, w: 34, h: 30, vx: speed, dir: Math.random() > .5 ? 1 : -1, minX, maxX, alive: true });
  }

  function buildWorld() {
    world.solids = [];
    world.platforms = [];
    world.pits = [];
    world.coins = [];
    world.gems = [];
    world.enemies = [];
    world.checkpoints = [];

    addGround(0, 1300);
    addGround(1450, 950);
    addGround(2600, 1020);
    addGround(3780, 1080);
    addGround(5040, 980);
    addGround(6210, 1080);
    addGround(7480, 1200);
    addGround(8860, 820);

    world.pits.push(rect(1300, FLOOR, 150, 200, 'pit'));
    world.pits.push(rect(2400, FLOOR, 200, 200, 'pit'));
    world.pits.push(rect(3620, FLOOR, 160, 200, 'pit'));
    world.pits.push(rect(4860, FLOOR, 180, 200, 'pit'));
    world.pits.push(rect(6020, FLOOR, 190, 200, 'pit'));
    world.pits.push(rect(7290, FLOOR, 190, 200, 'pit'));
    world.pits.push(rect(8680, FLOOR, 180, 200, 'pit'));

    // platform sets
    [
      [440, 520, 160], [700, 450, 120], [980, 380, 160],
      [1650, 500, 120], [1880, 430, 120], [2140, 360, 120],
      [2860, 520, 160], [3120, 440, 140], [3400, 360, 120],
      [4020, 510, 140], [4300, 430, 140], [4600, 350, 140],
      [5240, 520, 160], [5520, 440, 120], [5780, 360, 140],
      [6440, 520, 160], [6700, 440, 120], [6960, 370, 120],
      [7700, 500, 140], [7980, 420, 140], [8260, 340, 140],
      [9020, 510, 160]
    ].forEach(([x, y, w]) => addPlatform(x, y, w));

    // question blocks
    [560, 760, 1760, 1920, 2050, 3030, 3320, 4140, 4380, 5320, 5610, 6570, 6810, 7810, 8090].forEach((x) => {
      addQuestionBlock(x, 290);
      addCoin(x + 20, 250);
    });

    // coins on platforms
    for (const p of world.platforms) {
      const count = Math.max(2, Math.floor(p.w / 60));
      for (let i = 0; i < count; i++) {
        const cx = p.x + 20 + i * ((p.w - 40) / Math.max(1, count - 1));
        addCoin(cx, p.y - 22);
      }
    }

    // ground coins
    [220, 300, 980, 1140, 1560, 1740, 2050, 2680, 2880, 3320, 3960, 4480, 5160, 5480, 5760, 6460, 6840, 7560, 7920, 8360, 9080].forEach((x) => addCoin(x, FLOOR - 18));

    // gems high-value
    [1100, 2320, 3490, 4690, 5920, 7160, 8460].forEach((x) => addGem(x, 250));

    // enemies
    addEnemy(760, FLOOR - 30, 620, 1180, 75);
    addEnemy(1980, FLOOR - 30, 1600, 2320, 78);
    addEnemy(3160, FLOOR - 30, 2700, 3550, 82);
    addEnemy(4460, FLOOR - 30, 3940, 4780, 84);
    addEnemy(5700, FLOOR - 30, 5260, 5980, 86);
    addEnemy(6880, FLOOR - 30, 6400, 7250, 90);
    addEnemy(8180, FLOOR - 30, 7720, 8580, 92);

    world.checkpoints = [2200, 4700, 7200, 9000];
    world.flagX = 9300;
  }

  function resetPlayer(x = 90) {
    state.p = {
      x,
      y: 520,
      w: 36,
      h: 48,
      vx: 0,
      vy: 0,
      dir: 1,
      onGround: false,
      coyote: 0,
      jumpBuf: 0,
      invul: 0,
      walkT: 0
    };
  }

  function overlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function circleHit(c, r) {
    const nx = Math.max(r.x, Math.min(c.x, r.x + r.w));
    const ny = Math.max(r.y, Math.min(c.y, r.y + r.h));
    const dx = c.x - nx;
    const dy = c.y - ny;
    return dx * dx + dy * dy <= c.r * c.r;
  }

  function spawnParticles(x, y, color, n = 12, power = 3.2) {
    for (let i = 0; i < n; i++) {
      const a = Math.random() * Math.PI * 2;
      const s = 1.2 + Math.random() * power;
      state.particles.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s - 1.4, life: 20 + Math.random() * 20, color, r: 1.8 + Math.random() * 2.4 });
    }
  }

  function ensureAudio() {
    if (state.audio.ctx) return true;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return false;
    const ctxA = new AC();
    state.audio.ctx = ctxA;
    return true;
  }

  function tone(freq, dur = 0.1, type = 'triangle', vol = 0.07, at = null) {
    if (!state.audio.on || !state.audio.ctx) return;
    const ctxA = state.audio.ctx;
    const t0 = at ?? ctxA.currentTime;
    const o = ctxA.createOscillator();
    const g = ctxA.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(ctxA.destination);
    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }

  function sfx(kind) {
    if (!state.audio.ctx) return;
    const t = state.audio.ctx.currentTime;
    if (kind === 'jump') {
      tone(520, .09, 'triangle', .11, t);
      tone(760, .08, 'sine', .08, t + .02);
    } else if (kind === 'coin') {
      tone(980, .06, 'triangle', .12, t);
      tone(1310, .08, 'sine', .11, t + .02);
    } else if (kind === 'gem') {
      tone(660, .08, 'sine', .14, t);
      tone(880, .1, 'triangle', .12, t + .03);
      tone(1320, .12, 'sine', .1, t + .06);
    } else if (kind === 'stomp') {
      tone(320, .08, 'square', .1, t);
      tone(420, .08, 'triangle', .08, t + .03);
    } else if (kind === 'hurt') {
      tone(220, .12, 'square', .12, t);
      tone(170, .15, 'square', .1, t + .04);
    } else if (kind === 'clear') {
      tone(523, .12, 'triangle', .12, t);
      tone(659, .12, 'triangle', .12, t + .12);
      tone(784, .16, 'sine', .14, t + .24);
    }
  }

  function startBgm() {
    if (!state.audio.on || !state.audio.ctx || state.audio.bgm) return;
    const mel = [392, 440, 523, 440, 392, 440, 494, 587];
    const bass = [130, 146, 164, 174];
    let idx = 0;
    let b = 0;
    const play = () => {
      const base = state.audio.ctx.currentTime + 0.03;
      for (let i = 0; i < 8; i++) tone(mel[(idx + i) % mel.length], .17, 'sine', .045, base + i * .2);
      tone(bass[b % bass.length], .33, 'triangle', .04, base + .02);
      tone(bass[(b + 1) % bass.length], .33, 'triangle', .04, base + .82);
      idx = (idx + 2) % mel.length;
      b = (b + 1) % bass.length;
    };
    play();
    state.audio.bgm = setInterval(play, 1600);
  }

  function stopBgm() {
    if (state.audio.bgm) {
      clearInterval(state.audio.bgm);
      state.audio.bgm = null;
    }
  }

  function openMenu(message = '') {
    menu.classList.add('show');
    if (message) menuSub.textContent = message;
  }

  function closeMenu() {
    menu.classList.remove('show');
  }

  function nearestCheckpointX(x) {
    let cp = 90;
    for (const c of world.checkpoints) {
      if (x >= c) cp = c;
      else break;
    }
    return cp;
  }

  function loseLife() {
    state.lives -= 1;
    sfx('hurt');
    spawnParticles(state.p.x - state.camX + state.p.w / 2, state.p.y + 16, '#f43f5e', 20, 4);

    if (state.lives <= 0) {
      state.running = false;
      state.result = 'LOSE';
      openMenu('ì•„ì‰½ì§€ë§Œ ì‹¤íŒ¨! ë‹¤ì‹œ ë„ì „í•´ì„œ ì„±ê¹Œì§€ ë„ë‹¬í•˜ì„¸ìš”.');
      return;
    }
    const cx = nearestCheckpointX(state.p.x);
    resetPlayer(cx);
    state.p.invul = 1500;
  }

  function updatePlayer(dt) {
    const p = state.p;
    if (!p) return;

    const left = keys.has('ArrowLeft') || keys.has('KeyA') || touch.left;
    const right = keys.has('ArrowRight') || keys.has('KeyD') || touch.right;
    const jumpPressed = keys.has('Space') || keys.has('ArrowUp') || keys.has('KeyW') || touch.jump;

    const ACC = 1800;
    const MAX = 340;
    const DRAG = 2000;
    const GRAV = 1900;
    const JUMP = 760;

    if (left && !right) {
      p.vx -= ACC * dt;
      p.dir = -1;
    } else if (right && !left) {
      p.vx += ACC * dt;
      p.dir = 1;
    } else {
      if (p.vx > 0) p.vx = Math.max(0, p.vx - DRAG * dt);
      if (p.vx < 0) p.vx = Math.min(0, p.vx + DRAG * dt);
    }
    p.vx = Math.max(-MAX, Math.min(MAX, p.vx));

    if (jumpPressed) p.jumpBuf = 110;
    else p.jumpBuf -= dt * 1000;

    if (p.onGround) p.coyote = 90;
    else p.coyote -= dt * 1000;

    if (p.jumpBuf > 0 && p.coyote > 0) {
      p.vy = -JUMP;
      p.onGround = false;
      p.jumpBuf = 0;
      p.coyote = 0;
      sfx('jump');
    }

    p.vy += GRAV * dt;

    // move X
    p.x += p.vx * dt;
    for (const s of world.solids) {
      if (!overlap(p, s)) continue;
      if (p.vx > 0) p.x = s.x - p.w;
      else if (p.vx < 0) p.x = s.x + s.w;
      p.vx = 0;
    }

    // move Y
    p.y += p.vy * dt;
    p.onGround = false;
    for (const s of world.solids) {
      if (!overlap(p, s)) continue;
      if (p.vy > 0) {
        p.y = s.y - p.h;
        p.vy = 0;
        p.onGround = true;
      } else if (p.vy < 0) {
        p.y = s.y + s.h;
        p.vy = 0;
      }
    }

    if (p.x < 0) p.x = 0;
    if (p.x + p.w > world.width) p.x = world.width - p.w;

    if (p.y > H + 220) {
      loseLife();
      return;
    }

    // coins
    for (const c of world.coins) {
      if (c.taken) continue;
      if (circleHit(c, p)) {
        c.taken = true;
        state.coins += 1;
        state.score += 100;
        sfx('coin');
        spawnParticles(c.x - state.camX, c.y, '#facc15', 14, 3.6);
      }
    }

    // gems
    for (const g of world.gems) {
      if (g.taken) continue;
      if (circleHit(g, p)) {
        g.taken = true;
        state.score += 500;
        state.coins += 3;
        sfx('gem');
        spawnParticles(g.x - state.camX, g.y, '#a78bfa', 22, 4.5);
      }
    }

    // enemies
    for (const e of world.enemies) {
      if (!e.alive) continue;
      if (!overlap(p, e)) continue;

      const stomp = p.vy > 80 && p.y + p.h - e.y < 20;
      if (stomp) {
        e.alive = false;
        p.vy = -460;
        state.score += 180;
        sfx('stomp');
        spawnParticles(e.x - state.camX + e.w / 2, e.y + 10, '#92400e', 14, 3.2);
      } else if (p.invul <= 0) {
        loseLife();
        return;
      }
    }

    if (p.invul > 0) p.invul -= dt * 1000;

    p.walkT += Math.abs(p.vx) * dt;

    if (p.x >= world.flagX - 24) {
      state.running = false;
      state.result = 'WIN';
      sfx('clear');
      openMenu('ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´! ì½”ì¸ê³¼ ì ìˆ˜ë¥¼ ë” ë†’ì—¬ì„œ ìµœê³  ê¸°ë¡ì„ ë…¸ë ¤ë³´ì„¸ìš”.');
    }
  }

  function updateEnemies(dt) {
    for (const e of world.enemies) {
      if (!e.alive) continue;
      e.x += e.vx * e.dir * dt;
      if (e.x < e.minX) { e.x = e.minX; e.dir = 1; }
      if (e.x + e.w > e.maxX) { e.x = e.maxX - e.w; e.dir = -1; }
    }
  }

  function updateParticles(dt) {
    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += .08;
      p.life -= 60 * dt;
      if (p.life <= 0) state.particles.splice(i, 1);
    }
  }

  function updateCamera() {
    const target = state.p.x - W * 0.36;
    state.camX += (target - state.camX) * 0.1;
    state.camX = Math.max(0, Math.min(world.width - W, state.camX));
  }

  function update(dt, ts) {
    if (!state.running) return;

    state.time -= dt;
    if (state.time <= 0) {
      state.time = 0;
      state.running = false;
      state.result = 'LOSE';
      openMenu('ì‹œê°„ ì¢…ë£Œ! ë£¨íŠ¸ë¥¼ ìµœì í™”í•´ì„œ ë” ë¹ ë¥´ê²Œ í´ë¦¬ì–´í•˜ì„¸ìš”.');
      return;
    }

    updatePlayer(dt);
    updateEnemies(dt);
    updateParticles(dt);
    updateCamera();
  }

  function drawParallax() {
    // mountains back
    const m1 = [200, 760, 1280, 1890, 2520, 3320, 4150, 4980, 5800, 6640, 7480, 8350, 9200];
    ctx.fillStyle = '#93c5fd';
    for (const bx of m1) {
      const x = bx - state.camX * .2;
      ctx.beginPath();
      ctx.moveTo(x - 180, FLOOR);
      ctx.lineTo(x, 300);
      ctx.lineTo(x + 180, FLOOR);
      ctx.closePath();
      ctx.fill();
    }

    // hills mid
    const m2 = [120, 620, 1160, 1760, 2340, 2920, 3550, 4140, 4760, 5400, 6080, 6740, 7420, 8100, 8780, 9440];
    ctx.fillStyle = '#60a5fa';
    for (const bx of m2) {
      const x = bx - state.camX * .4;
      ctx.beginPath();
      ctx.ellipse(x, FLOOR + 10, 170, 90, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // clouds
    ctx.fillStyle = 'rgba(255,255,255,.85)';
    for (let i = 0; i < 18; i++) {
      const cx = i * 560 + 120 - state.camX * .3;
      const cy = 90 + (i % 3) * 70;
      if (cx < -200 || cx > W + 220) continue;
      ctx.beginPath();
      ctx.arc(cx, cy, 30, 0, Math.PI * 2);
      ctx.arc(cx + 32, cy - 12, 24, 0, Math.PI * 2);
      ctx.arc(cx + 60, cy, 22, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawWorld() {
    // pits
    for (const pit of world.pits) {
      const x = pit.x - state.camX;
      if (x + pit.w < -10 || x > W + 10) continue;
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(x, pit.y, pit.w, pit.h);
    }

    // solids
    for (const s of world.solids) {
      const x = s.x - state.camX;
      if (x + s.w < -60 || x > W + 60) continue;

      if (s.type === 'ground') {
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(x, s.y, s.w, s.h);
        ctx.fillStyle = '#4ade80';
        ctx.fillRect(x, s.y, s.w, 10);
        ctx.fillStyle = '#15803d';
        for (let i = 0; i < s.w; i += 30) ctx.fillRect(x + i, s.y + 14, 20, 8);
      } else if (s.type === 'platform') {
        ctx.fillStyle = '#b45309';
        ctx.fillRect(x, s.y, s.w, s.h);
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x, s.y, s.w, 5);
      } else if (s.type === 'qblock') {
        ctx.fillStyle = '#f59e0b';
        ctx.fillRect(x, s.y, s.w, s.h);
        ctx.strokeStyle = '#7c2d12';
        ctx.lineWidth = 3;
        ctx.strokeRect(x + 1.5, s.y + 1.5, s.w - 3, s.h - 3);
        ctx.fillStyle = '#7c2d12';
        ctx.font = 'bold 24px sans-serif';
        ctx.fillText('?', x + 13, s.y + 28);
      }
    }

    // flag
    const fx = world.flagX - state.camX;
    ctx.fillStyle = '#334155';
    ctx.fillRect(fx, 250, 8, 370);
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(fx + 8, 268, 62, 34);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 18px sans-serif';
    ctx.fillText('GO!', fx + 18, 291);

    // castle
    ctx.fillStyle = '#9ca3af';
    ctx.fillRect(fx + 70, 420, 140, 200);
    ctx.fillStyle = '#6b7280';
    ctx.fillRect(fx + 80, 390, 34, 30);
    ctx.fillRect(fx + 124, 380, 34, 40);
    ctx.fillRect(fx + 168, 390, 34, 30);
    ctx.fillStyle = '#374151';
    ctx.fillRect(fx + 124, 500, 30, 120);
  }

  function drawDecor() {
    // bushes and signboards
    const bushes = [260, 980, 1680, 2860, 4120, 5300, 6540, 7780, 9020];
    for (const bx of bushes) {
      const x = bx - state.camX;
      if (x < -120 || x > W + 120) continue;
      ctx.fillStyle = '#15803d';
      ctx.beginPath();
      ctx.arc(x, FLOOR - 12, 24, 0, Math.PI * 2);
      ctx.arc(x + 24, FLOOR - 16, 28, 0, Math.PI * 2);
      ctx.arc(x + 52, FLOOR - 12, 24, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#22c55e';
      ctx.beginPath();
      ctx.arc(x + 10, FLOOR - 18, 8, 0, Math.PI * 2);
      ctx.arc(x + 36, FLOOR - 22, 10, 0, Math.PI * 2);
      ctx.fill();
    }

    const signs = [1400, 2550, 5000, 7420];
    for (const sx of signs) {
      const x = sx - state.camX;
      if (x < -80 || x > W + 80) continue;
      ctx.fillStyle = '#7c2d12';
      ctx.fillRect(x, FLOOR - 54, 8, 54);
      ctx.fillStyle = '#fef3c7';
      ctx.fillRect(x + 8, FLOOR - 78, 64, 30);
      ctx.strokeStyle = '#92400e';
      ctx.strokeRect(x + 8.5, FLOOR - 77.5, 63, 29);
      ctx.fillStyle = '#7c2d12';
      ctx.font = 'bold 14px sans-serif';
      ctx.fillText('GO', x + 28, FLOOR - 58);
    }
  }

  function drawCoins(ts) {
    for (const c of world.coins) {
      if (c.taken) continue;
      const x = c.x - state.camX;
      if (x < -30 || x > W + 30) continue;
      const bob = Math.sin(ts * .006 + c.phase) * 4;
      const rx = 6 + Math.abs(Math.sin(ts * .008 + c.phase)) * 4;
      ctx.fillStyle = '#facc15';
      ctx.beginPath();
      ctx.ellipse(x, c.y + bob, rx, c.r, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#eab308';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    for (const g of world.gems) {
      if (g.taken) continue;
      const x = g.x - state.camX;
      if (x < -30 || x > W + 30) continue;
      const bob = Math.sin(ts * .006 + g.phase) * 5;
      ctx.save();
      ctx.translate(x, g.y + bob);
      ctx.rotate(ts * .002 + g.phase);
      ctx.fillStyle = '#a78bfa';
      ctx.beginPath();
      ctx.moveTo(0, -12);
      ctx.lineTo(10, 0);
      ctx.lineTo(0, 12);
      ctx.lineTo(-10, 0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  function drawEnemies() {
    for (const e of world.enemies) {
      if (!e.alive) continue;
      const x = e.x - state.camX;
      if (x + e.w < -30 || x > W + 30) continue;

      // body
      ctx.fillStyle = '#78350f';
      ctx.fillRect(x, e.y + 8, e.w, e.h - 8);
      // head
      ctx.fillStyle = '#92400e';
      ctx.fillRect(x + 4, e.y, e.w - 8, 12);
      // eyes
      ctx.fillStyle = '#fff';
      ctx.fillRect(x + 9, e.y + 4, 5, 5);
      ctx.fillRect(x + e.w - 14, e.y + 4, 5, 5);
    }
  }

  function drawPlayer() {
    const p = state.p;
    const x = p.x - state.camX;
    const blink = p.invul > 0 && Math.floor(p.invul / 90) % 2 === 0;
    if (blink) return;

    const footPhase = Math.sin(p.walkT * 0.08) * 2;

    // hair back
    ctx.fillStyle = '#7c2d12';
    ctx.fillRect(x + 8, p.y + 4, p.w - 16, 16);
    if (p.dir > 0) ctx.fillRect(x + p.w - 10, p.y + 14, 7, 11);
    else ctx.fillRect(x + 3, p.y + 14, 7, 11);

    // face
    ctx.fillStyle = '#fde68a';
    ctx.fillRect(x + 10, p.y + 6, p.w - 20, 12);

    // crown
    ctx.fillStyle = '#facc15';
    ctx.fillRect(x + 12, p.y, p.w - 24, 5);
    ctx.fillRect(x + 14, p.y - 4, 4, 4);
    ctx.fillRect(x + p.w - 18, p.y - 4, 4, 4);

    // torso
    ctx.fillStyle = '#db2777';
    ctx.fillRect(x + 8, p.y + 19, p.w - 16, 14);

    // skirt
    ctx.fillStyle = '#f472b6';
    ctx.beginPath();
    ctx.moveTo(x + 6, p.y + 33);
    ctx.lineTo(x + p.w - 6, p.y + 33);
    ctx.lineTo(x + p.w - 10, p.y + p.h - 4);
    ctx.lineTo(x + 10, p.y + p.h - 4);
    ctx.closePath();
    ctx.fill();

    // boots
    ctx.fillStyle = '#7f1d1d';
    ctx.fillRect(x + 10, p.y + p.h - 5 + footPhase, 8, 5);
    ctx.fillRect(x + p.w - 18, p.y + p.h - 5 - footPhase, 8, 5);

    // face details
    ctx.fillStyle = '#111827';
    ctx.fillRect(x + 13, p.y + 10, 2, 2);
    ctx.fillRect(x + p.w - 15, p.y + 10, 2, 2);

    // outline
    ctx.strokeStyle = 'rgba(17,24,39,.45)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(x + 7, p.y + 2, p.w - 14, p.h - 2);
  }

  function drawParticles() {
    for (const p of state.particles) {
      ctx.globalAlpha = Math.max(0, p.life / 30);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawOverlay() {
    if (state.running || menu.classList.contains('show')) return;
    ctx.fillStyle = 'rgba(15,23,42,.6)';
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '900 64px Inter, sans-serif';
    ctx.fillText(state.result === 'WIN' ? 'STAGE CLEAR!' : 'GAME OVER', W / 2, H / 2 - 30);
    ctx.font = '700 26px Inter, sans-serif';
    ctx.fillText(state.result === 'WIN' ? 'ê³µì£¼ ëŒ€ëª¨í—˜ ì„±ê³µ!' : 'í•œ ë²ˆ ë” ë„ì „!', W / 2, H / 2 + 18);
    ctx.font = '700 22px Inter, sans-serif';
    ctx.fillText('ìŠ¤í˜ì´ìŠ¤ / ì í”„ ë²„íŠ¼ìœ¼ë¡œ ì¬ì‹œì‘', W / 2, H / 2 + 62);
    ctx.textAlign = 'start';
  }

  function render(ts) {
    ctx.clearRect(0, 0, W, H);
    drawParallax();
    drawWorld();
    drawDecor();
    drawCoins(ts);
    drawEnemies();
    drawPlayer();
    drawParticles();
    drawOverlay();

    uiCoins.textContent = state.coins;
    uiScore.textContent = state.score.toLocaleString();
    uiLives.textContent = state.lives;
    uiTime.textContent = Math.max(0, Math.ceil(state.time));
    if (state.running) uiState.textContent = 'ì§„í–‰ì¤‘';
    else if (state.result === 'WIN') uiState.textContent = 'í´ë¦¬ì–´';
    else if (state.result === 'LOSE') uiState.textContent = 'ì‹¤íŒ¨';
    else uiState.textContent = 'ëŒ€ê¸°';

    const progress = Math.max(0, Math.min(100, Math.floor((state.p.x / world.flagX) * 100)));
    uiProgressText.textContent = `${progress}%`;
    uiProgressBar.style.width = `${progress}%`;
  }

  function resetGame() {
    buildWorld();
    resetPlayer(90);
    state.camX = 0;
    state.lives = 3;
    state.coins = 0;
    state.score = 0;
    state.time = 150;
    state.running = true;
    state.result = '';
    state.particles = [];
  }

  function loop(ts) {
    if (!state.lastTs) state.lastTs = ts;
    const dt = Math.min(0.033, (ts - state.lastTs) / 1000);
    state.lastTs = ts;

    update(dt, ts);
    render(ts);
    requestAnimationFrame(loop);
  }

  addEventListener('keydown', (e) => {
    const c = e.code;
    if (['ArrowLeft','ArrowRight','ArrowUp','Space','KeyA','KeyD','KeyW'].includes(c)) e.preventDefault();

    if (!state.firstInteraction) {
      state.firstInteraction = true;
      if (ensureAudio() && state.audio.ctx.state === 'suspended') state.audio.ctx.resume();
      startBgm();
    }

    if (!state.running && (c === 'Space' || c === 'ArrowUp' || c === 'KeyW')) {
      resetGame();
      closeMenu();
      return;
    }

    keys.add(c);
  }, { passive: false });

  addEventListener('keyup', (e) => keys.delete(e.code));

  function bindTouch(btn, key) {
    const down = (ev) => {
      ev.preventDefault();
      touch[key] = true;
      if (!state.firstInteraction) {
        state.firstInteraction = true;
        if (ensureAudio() && state.audio.ctx.state === 'suspended') state.audio.ctx.resume();
        startBgm();
      }
      if (!state.running && key === 'jump') { resetGame(); closeMenu(); }
    };
    const up = (ev) => { ev.preventDefault(); touch[key] = false; };

    btn.addEventListener('touchstart', down, { passive: false });
    btn.addEventListener('touchend', up, { passive: false });
    btn.addEventListener('touchcancel', up, { passive: false });
    btn.addEventListener('mousedown', down);
    btn.addEventListener('mouseup', up);
    btn.addEventListener('mouseleave', up);
  }

  bindTouch(document.getElementById('leftBtn'), 'left');
  bindTouch(document.getElementById('rightBtn'), 'right');
  bindTouch(document.getElementById('jumpBtn'), 'jump');

  addEventListener('blur', () => {
    keys.clear();
    touch.left = false;
    touch.right = false;
    touch.jump = false;
  });

  startGameBtn.onclick = () => {
    if (ensureAudio() && state.audio.ctx.state === 'suspended') state.audio.ctx.resume();
    state.firstInteraction = true;
    if (state.audio.on) startBgm();
    resetGame();
    closeMenu();
  };

  restartGameBtn.onclick = () => {
    if (ensureAudio() && state.audio.ctx.state === 'suspended') state.audio.ctx.resume();
    state.firstInteraction = true;
    if (state.audio.on) startBgm();
    resetGame();
    closeMenu();
  };

  soundBtn.onclick = () => {
    if (!ensureAudio()) return;
    if (state.audio.ctx.state === 'suspended') state.audio.ctx.resume();
    state.audio.on = !state.audio.on;
    soundBtn.textContent = state.audio.on ? 'ğŸ”Š' : 'ğŸ”ˆ';
    if (state.audio.on) startBgm();
    else stopBgm();
  };

  addEventListener('pointerdown', () => {
    if (!state.firstInteraction) {
      state.firstInteraction = true;
      if (ensureAudio() && state.audio.ctx.state === 'suspended') state.audio.ctx.resume();
      startBgm();
    }
  }, { passive: true });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden) stopBgm();
    else if (state.audio.on && state.firstInteraction) startBgm();
  });

  resetGame();
  state.running = false;
  state.result = 'READY';
  openMenu('ì„±ìœ¼ë¡œ í–¥í•˜ëŠ” ê¸¸ì„ ëŒíŒŒí•˜ì„¸ìš”. ì½”ì¸ê³¼ ì ¬ì„ ëª¨ì•„ ìµœê³  ì ìˆ˜ë¥¼ ë‹¬ì„±í•˜ì„¸ìš”.');
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
