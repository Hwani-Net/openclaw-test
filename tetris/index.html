<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>NEON TETRIS</title>
  <style>
    :root {
      --bg1: #020617;
      --bg2: #0f172a;
      --panel: rgba(15, 23, 42, 0.75);
      --line: rgba(148, 163, 184, .3);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #22d3ee;
      --danger: #f43f5e;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 700px at 20% -10%, #0ea5e955, transparent 45%),
                  radial-gradient(900px 600px at 120% 30%, #a855f755, transparent 40%),
                  linear-gradient(180deg, var(--bg2), var(--bg1));
      color: var(--text);
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }

    .app {
      display: grid;
      grid-template-columns: 1fr min(420px, 100vw) 1fr;
      height: 100%;
      padding: 14px;
      gap: 14px;
    }

    .center {
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: 10px;
      align-items: start;
      justify-items: center;
    }

    .title {
      text-align: center;
      letter-spacing: .12em;
      font-weight: 900;
      font-size: clamp(20px, 4vw, 28px);
      background: linear-gradient(90deg, #22d3ee, #a78bfa, #f472b6);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 24px rgba(56, 189, 248, .2);
    }

    .topbar {
      width: 100%;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 8px 10px;
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 28px rgba(2, 6, 23, .35);
    }

    .k { font-size: 10px; color: var(--muted); text-transform: uppercase; letter-spacing: .08em; }
    .v { font-size: 18px; font-weight: 800; margin-top: 2px; }

    .stage-wrap {
      width: 100%;
      display: grid;
      grid-template-columns: 96px 1fr 96px;
      gap: 10px;
      align-items: start;
    }

    .side {
      display: grid;
      gap: 10px;
    }

    .mini-title {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .08em;
      margin-bottom: 6px;
    }

    .mini {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: linear-gradient(180deg, #0b1225, #0a0f1f);
      display: block;
    }

    .board-shell {
      border-radius: 18px;
      padding: 10px;
      background: linear-gradient(180deg, rgba(15, 23, 42, .95), rgba(15, 23, 42, .75));
      border: 1px solid rgba(148, 163, 184, .4);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.05), 0 14px 34px rgba(2,6,23,.45);
    }

    canvas#board {
      width: 100%;
      max-width: 300px;
      aspect-ratio: 10 / 20;
      border-radius: 12px;
      display: block;
      background: linear-gradient(180deg, #0a1020, #060b16);
      border: 1px solid rgba(148, 163, 184, .25);
    }

    .controls {
      width: 100%;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .btn {
      appearance: none;
      border: 1px solid rgba(148, 163, 184, .45);
      background: linear-gradient(180deg, rgba(30, 41, 59, .95), rgba(15, 23, 42, .95));
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 700;
      letter-spacing: .03em;
      cursor: pointer;
      transition: transform .06s ease, border-color .2s ease, box-shadow .2s ease;
      box-shadow: 0 6px 20px rgba(2, 6, 23, .35);
    }

    .btn:hover { border-color: rgba(34, 211, 238, .7); box-shadow: 0 0 0 2px rgba(34, 211, 238, .15), 0 8px 24px rgba(2,6,23,.45); }
    .btn:active { transform: translateY(1px) scale(.99); }
    .btn.danger:hover { border-color: rgba(244, 63, 94, .85); box-shadow: 0 0 0 2px rgba(244,63,94,.15), 0 8px 24px rgba(2,6,23,.45); }

    .hint {
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
      text-align: center;
    }

    .toast {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(2, 132, 199, .2);
      border: 1px solid rgba(34, 211, 238, .6);
      color: #a5f3fc;
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 700;
      letter-spacing: .02em;
      opacity: 0;
      pointer-events: none;
      transition: opacity .25s ease;
      z-index: 20;
      backdrop-filter: blur(6px);
    }

    .toast.show { opacity: 1; }

    .mobile-pad {
      width: 100%;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 8px;
    }

    .pad-btn {
      border: 1px solid rgba(148,163,184,.45);
      background: rgba(15,23,42,.9);
      border-radius: 12px;
      color: #e2e8f0;
      padding: 12px 8px;
      font-size: 15px;
      font-weight: 800;
      user-select: none;
      text-align: center;
    }

    @media (min-width: 980px) {
      .mobile-pad { display: none; }
    }

    @media (max-width: 979px) {
      .app { grid-template-columns: 1fr; padding: 8px; }
      .stage-wrap { grid-template-columns: 76px 1fr 76px; }
      .topbar { grid-template-columns: repeat(2, 1fr); }
      .controls { grid-template-columns: repeat(2, 1fr); }
      canvas#board { max-width: min(86vw, 360px); }
    }
  </style>
</head>
<body>
  <div class="app">
    <div></div>

    <div class="center">
      <div class="title">NEON TETRIS</div>

      <div class="topbar">
        <div class="card"><div class="k">Score</div><div class="v" id="score">0</div></div>
        <div class="card"><div class="k">Level</div><div class="v" id="level">1</div></div>
        <div class="card"><div class="k">Lines</div><div class="v" id="lines">0</div></div>
        <div class="card"><div class="k">High</div><div class="v" id="high">0</div></div>
      </div>

      <div class="stage-wrap">
        <div class="side">
          <div class="card">
            <div class="mini-title">Hold</div>
            <canvas class="mini" id="hold" width="80" height="80"></canvas>
          </div>
        </div>

        <div class="board-shell">
          <canvas id="board" width="300" height="600"></canvas>
        </div>

        <div class="side">
          <div class="card">
            <div class="mini-title">Next</div>
            <canvas class="mini" id="next" width="80" height="80"></canvas>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="btnPause">일시정지</button>
        <button class="btn danger" id="btnRestart">새 게임</button>
      </div>

      <div class="mobile-pad" id="mobilePad">
        <div class="pad-btn" data-act="left">◀</div>
        <div class="pad-btn" data-act="right">▶</div>
        <div class="pad-btn" data-act="down">▼</div>
        <div class="pad-btn" data-act="drop">⤓</div>
        <div class="pad-btn" data-act="rotL">⟲</div>
        <div class="pad-btn" data-act="rotR">⟳</div>
        <div class="pad-btn" data-act="hold">HOLD</div>
        <div class="pad-btn" data-act="pause">⏯</div>
      </div>

      <div class="hint">
        ←/→ 이동 · ↓ 소프트드롭 · Space 하드드롭 · ↑/X 회전 · Z 반시계 · C 홀드 · P 일시정지
      </div>
    </div>

    <div></div>
  </div>

  <div class="toast" id="toast">READY</div>

<script>
(() => {
  const COLS = 10;
  const ROWS = 20;

  const PIECES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    O: [[1,1],[1,1]],
    T: [[0,1,0],[1,1,1],[0,0,0]],
    S: [[0,1,1],[1,1,0],[0,0,0]],
    Z: [[1,1,0],[0,1,1],[0,0,0]],
    J: [[1,0,0],[1,1,1],[0,0,0]],
    L: [[0,0,1],[1,1,1],[0,0,0]]
  };

  const COLORS = {
    I: '#22d3ee', O: '#facc15', T: '#a78bfa', S: '#4ade80',
    Z: '#f87171', J: '#60a5fa', L: '#fb923c', GHOST: 'rgba(203,213,225,.18)'
  };

  const SCORE_TABLE = [0, 100, 300, 500, 800];

  const boardCanvas = document.getElementById('board');
  const boardCtx = boardCanvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const holdCanvas = document.getElementById('hold');
  const nextCtx = nextCanvas.getContext('2d');
  const holdCtx = holdCanvas.getContext('2d');

  const ui = {
    score: document.getElementById('score'),
    level: document.getElementById('level'),
    lines: document.getElementById('lines'),
    high: document.getElementById('high'),
    toast: document.getElementById('toast'),
    btnPause: document.getElementById('btnPause'),
    btnRestart: document.getElementById('btnRestart'),
    mobilePad: document.getElementById('mobilePad')
  };

  const state = {
    board: [],
    bag: [],
    queue: [],
    current: null,
    hold: null,
    holdUsed: false,
    score: 0,
    lines: 0,
    level: 1,
    high: Number(localStorage.getItem('neon-tetris-high') || 0),
    gameOver: false,
    paused: false,
    dropCounter: 0,
    dropInterval: 900,
    lastTime: 0
  };

  function toast(text, ms = 850) {
    ui.toast.textContent = text;
    ui.toast.classList.add('show');
    clearTimeout(toast.t);
    toast.t = setTimeout(() => ui.toast.classList.remove('show'), ms);
  }

  function createBoard() {
    return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
  }

  function cloneMatrix(m) {
    return m.map(r => r.slice());
  }

  function randomBag() {
    const arr = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = (Math.random() * (i + 1)) | 0;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function fillQueue() {
    while (state.queue.length < 5) {
      if (state.bag.length === 0) state.bag = randomBag();
      state.queue.push(state.bag.pop());
    }
  }

  function pieceFromType(type) {
    const matrix = cloneMatrix(PIECES[type]);
    return { type, matrix, x: ((COLS - matrix[0].length) / 2) | 0, y: -1 };
  }

  function spawnPiece() {
    fillQueue();
    const t = state.queue.shift();
    const p = pieceFromType(t);
    state.current = p;
    state.holdUsed = false;
    fillQueue();

    if (collide(state.board, p)) {
      state.gameOver = true;
      state.paused = false;
      state.high = Math.max(state.high, state.score);
      localStorage.setItem('neon-tetris-high', String(state.high));
      toast('GAME OVER', 1600);
    }
  }

  function resetGame() {
    state.board = createBoard();
    state.bag = [];
    state.queue = [];
    state.current = null;
    state.hold = null;
    state.holdUsed = false;
    state.score = 0;
    state.lines = 0;
    state.level = 1;
    state.dropCounter = 0;
    state.dropInterval = 900;
    state.gameOver = false;
    state.paused = false;
    spawnPiece();
    render();
    toast('READY');
  }

  function updateLevel() {
    state.level = Math.floor(state.lines / 10) + 1;
    state.dropInterval = Math.max(85, 900 - (state.level - 1) * 70);
  }

  function collide(board, piece, offX = 0, offY = 0, matrix = piece.matrix) {
    for (let y = 0; y < matrix.length; y++) {
      for (let x = 0; x < matrix[y].length; x++) {
        if (!matrix[y][x]) continue;
        const bx = piece.x + x + offX;
        const by = piece.y + y + offY;
        if (bx < 0 || bx >= COLS || by >= ROWS) return true;
        if (by >= 0 && board[by][bx]) return true;
      }
    }
    return false;
  }

  function merge(board, piece) {
    piece.matrix.forEach((row, y) => {
      row.forEach((v, x) => {
        if (!v) return;
        const by = piece.y + y;
        const bx = piece.x + x;
        if (by >= 0) board[by][bx] = piece.type;
      });
    });
  }

  function clearLines() {
    let lines = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!state.board[y][x]) continue outer;
      }
      const row = state.board.splice(y, 1)[0].fill(0);
      state.board.unshift(row);
      lines++;
      y++;
    }

    if (lines > 0) {
      state.lines += lines;
      state.score += SCORE_TABLE[lines] * state.level;
      updateLevel();
      toast(lines === 4 ? 'TETRIS!' : `+${lines} LINE`);
    }
  }

  function rotateMatrixCW(m) {
    const N = m.length;
    const M = m[0].length;
    const out = Array.from({ length: M }, () => Array(N).fill(0));
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < M; x++) {
        out[x][N - 1 - y] = m[y][x];
      }
    }
    return out;
  }

  function rotateMatrixCCW(m) {
    const N = m.length;
    const M = m[0].length;
    const out = Array.from({ length: M }, () => Array(N).fill(0));
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < M; x++) {
        out[M - 1 - x][y] = m[y][x];
      }
    }
    return out;
  }

  function tryRotate(dir = 1) {
    if (state.gameOver || state.paused) return;
    const p = state.current;
    if (!p) return;

    const rotated = dir > 0 ? rotateMatrixCW(p.matrix) : rotateMatrixCCW(p.matrix);
    const kicks = [0, -1, 1, -2, 2];

    for (const k of kicks) {
      if (!collide(state.board, p, k, 0, rotated)) {
        p.matrix = rotated;
        p.x += k;
        return;
      }
    }
  }

  function move(dx) {
    if (state.gameOver || state.paused) return;
    const p = state.current;
    if (!p) return;
    if (!collide(state.board, p, dx, 0)) p.x += dx;
  }

  function softDrop() {
    if (state.gameOver || state.paused) return;
    const p = state.current;
    if (!p) return;

    if (!collide(state.board, p, 0, 1)) {
      p.y += 1;
      state.score += 1;
      return;
    }

    lockAndContinue();
  }

  function hardDrop() {
    if (state.gameOver || state.paused) return;
    const p = state.current;
    if (!p) return;

    let dist = 0;
    while (!collide(state.board, p, 0, 1)) {
      p.y += 1;
      dist++;
    }
    state.score += dist * 2;
    lockAndContinue();
  }

  function holdCurrent() {
    if (state.gameOver || state.paused || state.holdUsed) return;
    const curType = state.current.type;

    if (!state.hold) {
      state.hold = curType;
      spawnPiece();
    } else {
      const temp = state.hold;
      state.hold = curType;
      state.current = pieceFromType(temp);
      if (collide(state.board, state.current)) {
        state.gameOver = true;
        toast('GAME OVER', 1400);
      }
    }

    state.holdUsed = true;
  }

  function lockAndContinue() {
    const p = state.current;
    merge(state.board, p);
    clearLines();
    state.high = Math.max(state.high, state.score);
    localStorage.setItem('neon-tetris-high', String(state.high));
    spawnPiece();
  }

  function ghostY(piece) {
    let y = piece.y;
    while (!collide(state.board, piece, 0, (y - piece.y) + 1)) y++;
    return y;
  }

  function drawCell(ctx, x, y, color, size, glow = false) {
    const px = x * size;
    const py = y * size;
    const r = Math.max(2, size * 0.16);

    if (glow) {
      ctx.shadowColor = color;
      ctx.shadowBlur = 14;
    } else {
      ctx.shadowBlur = 0;
    }

    ctx.fillStyle = color;
    roundRect(ctx, px + 1, py + 1, size - 2, size - 2, r);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(255,255,255,.14)';
    roundRect(ctx, px + 1.5, py + 1.5, size - 3, size - 3, r);
    ctx.stroke();
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function drawBoard() {
    const ctx = boardCtx;
    const size = boardCanvas.width / COLS;

    ctx.clearRect(0, 0, boardCanvas.width, boardCanvas.height);

    // Grid
    ctx.strokeStyle = 'rgba(148,163,184,.09)';
    ctx.lineWidth = 1;
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x * size + .5, 0);
      ctx.lineTo(x * size + .5, boardCanvas.height);
      ctx.stroke();
    }
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * size + .5);
      ctx.lineTo(boardCanvas.width, y * size + .5);
      ctx.stroke();
    }

    // Locked blocks
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const t = state.board[y][x];
        if (!t) continue;
        drawCell(ctx, x, y, COLORS[t], size, true);
      }
    }

    // Current piece + ghost
    const p = state.current;
    if (p && !state.gameOver) {
      const gy = ghostY(p);
      p.matrix.forEach((row, yy) => row.forEach((v, xx) => {
        if (!v) return;
        const gx = p.x + xx;
        const gyy = gy + yy;
        if (gyy >= 0) drawCell(ctx, gx, gyy, COLORS.GHOST, size, false);
      }));

      p.matrix.forEach((row, yy) => row.forEach((v, xx) => {
        if (!v) return;
        const bx = p.x + xx;
        const by = p.y + yy;
        if (by >= 0) drawCell(ctx, bx, by, COLORS[p.type], size, true);
      }));
    }

    // Overlay text
    if (state.paused || state.gameOver) {
      ctx.fillStyle = 'rgba(2,6,23,.72)';
      ctx.fillRect(0, 0, boardCanvas.width, boardCanvas.height);
      ctx.fillStyle = '#e2e8f0';
      ctx.font = '700 28px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(state.gameOver ? 'GAME OVER' : 'PAUSED', boardCanvas.width / 2, boardCanvas.height / 2 - 8);
      ctx.font = '500 13px Inter, sans-serif';
      ctx.fillStyle = '#94a3b8';
      ctx.fillText(state.gameOver ? 'R 또는 새 게임 버튼으로 다시 시작' : 'P 또는 버튼으로 재개', boardCanvas.width / 2, boardCanvas.height / 2 + 20);
    }
  }

  function drawMini(canvas, ctx, type) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'rgba(148,163,184,.06)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!type) return;

    const m = PIECES[type];
    const cols = m[0].length;
    const rows = m.length;
    const cell = Math.floor(Math.min(canvas.width / (cols + 2), canvas.height / (rows + 2)));
    const ox = Math.floor((canvas.width - cols * cell) / 2);
    const oy = Math.floor((canvas.height - rows * cell) / 2);

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        if (!m[y][x]) continue;
        const px = ox + x * cell;
        const py = oy + y * cell;
        ctx.fillStyle = COLORS[type];
        roundRect(ctx, px + 1, py + 1, cell - 2, cell - 2, 5);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,.18)';
        roundRect(ctx, px + 1, py + 1, cell - 2, cell - 2, 5);
        ctx.stroke();
      }
    }
  }

  function render() {
    drawBoard();
    drawMini(nextCanvas, nextCtx, state.queue[0]);
    drawMini(holdCanvas, holdCtx, state.hold);

    ui.score.textContent = state.score;
    ui.level.textContent = state.level;
    ui.lines.textContent = state.lines;
    ui.high.textContent = state.high;

    ui.btnPause.textContent = state.paused ? '재개' : '일시정지';
  }

  function gameLoop(time = 0) {
    const dt = time - state.lastTime;
    state.lastTime = time;

    if (!state.paused && !state.gameOver) {
      state.dropCounter += dt;
      if (state.dropCounter >= state.dropInterval) {
        state.dropCounter = 0;
        softDrop();
      }
    }

    render();
    requestAnimationFrame(gameLoop);
  }

  function togglePause() {
    if (state.gameOver) return;
    state.paused = !state.paused;
    toast(state.paused ? 'PAUSE' : 'RESUME');
  }

  function onAction(act) {
    switch (act) {
      case 'left': move(-1); break;
      case 'right': move(1); break;
      case 'down': softDrop(); break;
      case 'drop': hardDrop(); break;
      case 'rotL': tryRotate(-1); break;
      case 'rotR': tryRotate(1); break;
      case 'hold': holdCurrent(); break;
      case 'pause': togglePause(); break;
    }
  }

  document.addEventListener('keydown', (e) => {
    const k = e.code;

    if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp','Space','KeyZ','KeyX','KeyC','KeyP','KeyR'].includes(k)) {
      e.preventDefault();
    }

    if (k === 'ArrowLeft') move(-1);
    else if (k === 'ArrowRight') move(1);
    else if (k === 'ArrowDown') softDrop();
    else if (k === 'Space') hardDrop();
    else if (k === 'ArrowUp' || k === 'KeyX') tryRotate(1);
    else if (k === 'KeyZ') tryRotate(-1);
    else if (k === 'KeyC') holdCurrent();
    else if (k === 'KeyP') togglePause();
    else if (k === 'KeyR') resetGame();
  }, { passive: false });

  ui.btnPause.addEventListener('click', togglePause);
  ui.btnRestart.addEventListener('click', resetGame);

  ui.mobilePad.addEventListener('touchstart', (e) => {
    const btn = e.target.closest('.pad-btn');
    if (!btn) return;
    e.preventDefault();
    onAction(btn.dataset.act);
  }, { passive: false });

  ui.mobilePad.addEventListener('click', (e) => {
    const btn = e.target.closest('.pad-btn');
    if (!btn) return;
    onAction(btn.dataset.act);
  });

  // init
  state.board = createBoard();
  spawnPiece();
  toast('NEON TETRIS');
  render();
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>
